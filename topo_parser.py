#!/usr/bin/python

##############################################################################################
# Copyright (C) 2014 Pier Luigi Ventre - (Consortium GARR and University of Rome "Tor Vergata")
# Copyright (C) 2014 Giuseppe Siracusano, Stefano Salsano - (CNIT and University of Rome "Tor Vergata")
# www.garr.it - www.uniroma2.it/netgroup - www.cnit.it
#
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Topology Parser.
#
# @author Pier Luigi Ventre <pl.ventre@gmail.com>
# @author Giuseppe Siracusano <a_siracusano@tin.it>
# @author Stefano Salsano <stefano.salsano@uniroma2.it>
#
#

import os
import json
import sys
from topo_parser_utils import Subnet

class TopoParser:
	
	path = ""
	
	# Init Function, load json_data from path_json
	def __init__(self, path_json, verbose=False):
		self.verbose = verbose
		self.cr_oshis = []
		self.pe_oshis = []
		self.l2sws = []
		self.cers = []
		self.vlls = []
		self.pplinks = []
		self.l2links = []
		self.ppsubnets = []
		self.l2subnets = []
		self.subnetclass = Subnet
		self.autogenerated = False
		self.parsed = False
		if self.verbose:
			print "*** __init__:"
		path_json = self.path + path_json
		if os.path.exists(path_json) == False:
			print "Error Topo File %s Not Found" % path_json
			sys.exit(-2)
		json_file=open(path_json)
		self.json_data = json.load(json_file)
		json_file.close()
		if self.verbose:
			print "*** JSON Data Loaded:"
			#print json.dumps(self.json_data, sort_keys=True, indent=4)

	# Parse Function, first retrieves the vertices from json data,
	# second retrieves the links from json data, finally create the
	# subnets (PPsubnet, Core L2Subnet, Access L2Subnet)
	def parse_data(self):
		self.load_advanced()
		self.load_vertex()
		self.load_links()
		self.create_subnet()
		self.parsed = True
	
	def getsubnets(self):
		if self.parsed == False:
			self.parse_data()
		return (self.ppsubnets, self.l2subnets)

	def getVLLs(self):
		if self.parsed == False:
			self.parse_data()
		return self.vlls

	def load_advanced(self):
		if self.verbose:
			print "*** Retrieve Advanced Option"
		advanced_options = self.json_data['advanced']
		if 'tunneling' not in advanced_options:
			print "*** Error No Tunneling Data"
			sys.exit(-2)
		self.tunneling = advanced_options['tunneling']
		if self.tunneling == "":
			self.tunneling = "VXLAN"
		

	# Parses vertex from json_data, renames the node in 'vertices' and in 'edges', 
	# and divides them in: oshi (Core Oshi), aoshi (Access Oshi), l2sws (Legacy L2 switch)
	# and euhs (End User Host). 
	# TODO Parse Nodes Properties
	def load_vertex(self):
		if self.verbose:
			print "*** Retrieve Vertex"
		vertices = self.json_data['vertices']
		edges = self.json_data['edges']
		for vertex in vertices:
			if 'CROSHI' in vertex:
				data = vertex.split('#')
				name = "cro" + str(len(self.cr_oshis) + len(self.pe_oshis) + 1)
				self.cr_oshis.append(name) 
			elif 'PEOSHI' in vertex:
				data = vertex.split('#')
				name = "peo" + str(len(self.cr_oshis) + len(self.pe_oshis) + 1)
				self.pe_oshis.append(name)
			elif 'SWI' in vertex:
				data = vertex.split('#')
				name = "swi" + str(len(self.l2sws) + 1)
				self.l2sws.append(name)
			elif 'CER' in vertex:
				data = vertex.split('#')
				name = "cer" + str(len(self.cers) + 1)
				self.cers.append(name)
			for edge in edges:
				i = 0
				for side in edge:
					if vertex in side:
						edge[i] = name
					i = i + 1
		if self.verbose:		
			print "*** CROSHI:", self.cr_oshis
			print "*** PEOSHI:", self.pe_oshis
			print "*** L2SW:", self.l2sws
			print "*** CER:", self.cers

	# Parses link from json_data, then divides them in L2Links (Switched Links)
	# and PPLinks (Point To Point Links)
	# TODO Parse Links Properties
	def load_links(self):
		if self.verbose:
			print "*** Retrieve Links"
		edges = self.json_data['edges']
		for edge in edges:
			multilinks = edge[2]
			for link in multilinks:
				if link['vll'] == False:
					if 'swi' in edge[0] or 'swi' in edge[1]:
						self.l2links.append((edge[0], edge[1], link))
					else:
						self.pplinks.append((edge[0], edge[1], link))
				else:
						self.vlls.append((edge[0], edge[1], link))
		if self.verbose:
			print "*** L2links:", self.l2links
			print "*** PPlinks:", self.pplinks
			print "*** VLLs:", self.vlls
	# From the parsed Links, creates the associates Subnet, then divides them in
	# L2subnet and PPsubnets
	def create_subnet(self):
		# Creates the ppsubnets
		for pplink in self.pplinks:
			#print pplink
			s = self.subnetclass()
			s.appendLink(pplink)
			self.ppsubnets.append(s)
		# Eliminates all links
		self.pplinks = []
		if self.verbose:
			i = 0
			print "*** Subnets:"
			for subnet in self.ppsubnets:
				print "*** PP Subnet(%s): Nodes %s - Links %s" %(i + 1, subnet.nodes, subnet.links)
				i = i + 1
		# Creates the l2subnets
		tmp = []
		for sw in self.l2sws:
			tmp.append(sw)
			s = self.subnetclass()
			while len(tmp) > 0:
				current = tmp[0]
				tmp.pop(0)
				(hops, links) = self.getNextHopAndLinks(current)
				for hop in hops:
					tmp.append(hop)
				for link in links:
					s.appendLink(link)
			if len(s.links) > 0:
				self.l2subnets.append(s)	
		if self.verbose:
			i = 0
			print "*** Subnets:"
			for subnet in self.l2subnets:
				print "*** L2 Subnet(%s): Nodes %s - Links %s" %(i + 1, subnet.nodes, subnet.links)
				i = i + 1

	# Utility Function, provides node's next hop and links (to the nexthop)
	# we use it to rebuild from scratch a l2subnets, XXX it deletes the l2links
	# once we rebuild the subnet
	def getNextHopAndLinks(self,node):
		ret_links = []
		ret_node = []
		tmp = []
		if 'cer' in node or 'peo' in node or 'cro' in node:
			return ([],[])
		for link in self.l2links:
			if link[0] == node or link[1] == node:
				ret_links.append(link)
				if link[0] == node:
					ret_node.append(link[1])
				if link[1] == node:
					ret_node.append(link[0])
				tmp.append(link)
		for link in tmp:
			self.l2links.remove(link)
		return (ret_node, ret_links)

if __name__ == '__main__':

	parser = TopoParser("../Dreamer-Mininet-Extensions/topo/topo.json", verbose = True)
	(ppsubnets, l2subnets) = parser.getsubnets()
	print "*** Networks Point To Point"
	for ppsubnet in ppsubnets:
			links = ppsubnet.links
			print "*** Subnet: Node %s - Links %s" %(ppsubnet.nodes, links)
	print "*** Switched Networks"
	for l2subnet in l2subnets:
			links = l2subnet.links
			print "*** Subnet: Node %s - Links %s" %(l2subnet.nodes, links)
	print "*** VLLs",parser.getVLLs()
	print "*** Tunneling", parser.tunneling
